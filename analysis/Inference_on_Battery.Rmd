---
title: "Inference Battery"
author: "Davide"
date: "2025-10-17"
output:
  pdf_document:
    fig_width: 4
    fig_height: 2.5
  html_document:
    df_print: paged
  word_document: default
  html_notebook: default
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
# Set echo=TRUE to show code in the output for transparency
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(survival)
library(dplyr)
library(lubridate)

# Read data, skipping header lines and marking '---' as NA
data <- read.csv("DirtSlurper3100.csv", skip = 12, na.strings = "---", stringsAsFactors = FALSE)

# Convert dates from character to Date class
data$Registration.date <- dmy(data$Registration.date)
data$Failure.date <- dmy(data$Failure.date)

# Exclude extreme use cases (>=2400 hours of use)
data_filtered <- filter(data, Total.usage.time < 2400)

# Dimensions after filtering
dim(data_filtered)

```

```{r}
# Define event indicator for battery failure (1 if battery failed, 0 if censored)
data_filtered$Event <- ifelse(data_filtered$Battery.status == "Damage", 1, 0)
cutoff_date <- as.Date("2020-01-01")

# Preprocessing not to lose any useful data
data_filtered <- data %>%
  dplyr::filter(Total.usage.time < 2400) %>%
  dplyr::mutate(
    # Event = 1 only if Battery.status explicitly says "Damage"; 0 otherwise (including NA)
    Event     = as.integer(!is.na(Battery.status) & Battery.status == "Damage"),
    End.date  = dplyr::if_else(!is.na(Failure.date), Failure.date, cutoff_date),
    time_days = as.numeric(End.date - Registration.date)
  )

# keep rows with a valid non-negative time
surv_data <- data_filtered %>% dplyr::filter(!is.na(time_days), time_days >= 0) %>%
  dplyr::select(time_days, Total.usage.time, Event)

# define usage groups in an ordereded way, so colors and legends are consistent
data_filtered <- data_filtered %>%
  dplyr::mutate(
    usage_rate = Total.usage.time / pmax(time_days, 1),
    UsageGroup = factor(
      ifelse(usage_rate >= median(usage_rate, na.rm=TRUE), "High usage", "Low usage"),
      levels = c("High usage", "Low usage")
    )
  )

summary(surv_data$time_days)    # Observed times (in days)
table(surv_data$Event)          # Censored (0) vs Events (1)

```


```{r}
# Kaplan-Meier survival estimation for battery lifetime
KM_fit <- survfit(Surv(time_days, Event) ~ 1, data = surv_data)
KM_fit

# Survival probability estimates at specific time points (1 yr, 2 yr, 1000 days, 3 years)
summary(KM_fit, times = c(365, 730, 1000, 1095))
```

```{r plotKM}
# Plot the Kaplan-Meier survival curve with 95% confidence interval
plot(KM_fit, conf.int = TRUE, mark.time = FALSE,
     xlab = "Time since Registration (days)", ylab = "Survival Probability",
     main = "Kaplan–Meier Estimate of Battery Survival")
```




```{r}
# Fit a Weibull accelerated failure-time model for battery lifetime
weibull_fit <- survreg(Surv(time_days, Event) ~ 1, data = surv_data, dist = "weibull")
summary(weibull_fit)

# Extract Weibull parameters (shape and scale) from survreg output
weibull_shape <- 1 / weibull_fit$scale
weibull_scale <- exp(coef(weibull_fit))
weibull_shape
weibull_scale

# Compute L10 estimated in days (the time by which 10% of batteries have failed) from Weibull model
L10_param <- weibull_scale * (-log(0.9))^(1 / weibull_shape)
L10_param
```

## Sanity check

```{r weibull_sanity_check}

# Weibull sanity check: log{-log S(t)} vs log(t) 
KM_fit <- survfit(Surv(time_days, Event) ~ 1, data = surv_data) 
t <- KM_fit$time 
S <- KM_fit$surv 
idx <- which(t > 0 & S > 0 & S < 1) 
x <- log(t[idx]) 
y <- log(-log(S[idx])) 

# y = a + bx, where b = beta and a = -beta*log(alpha)) 
lin_fit <- lm(y ~ x)

plot(x, y, pch = 16, cex=0.5, 
     xlab ="log(time)", ylab = "log(-log(S(t)))",
     main = "Weibull sanity check with log-log plot")
abline(lin_fit, col="blue", lwd=2)

```
```{r weibull sanity check 2}
# Weibull sanity check: log{-log S(t)} vs log(t)
KM_fit <- survfit(Surv(time_days, Event) ~ 1, data = surv_data)

t <- KM_fit$time
S <- KM_fit$surv

idx <- which(t > 0 & S > 0.1 & S < 0.9)
x <- log(t[idx])
y <- log(-log(S[idx]))

# y = a + b x, where b = beta and a = -beta*log(alpha)
lin_fit <- lm(y ~ x)

plot(x, y, pch = 16, cex = 0.5,
     xlab = "log(time)", ylab = "log(-log(S(t)))",
     main = "Weibull sanity check with log–log plot (0.1 < S < 0.9)")
abline(lin_fit, col = "blue", lwd = 2)

```




```{r plotKM no CI}

# Parametric Weibull survival curve on the KM curve for comparison
plot(KM_fit, conf.int = FALSE, mark.time = FALSE, 
     xlab = "Time since Registration (days)", ylab = "Survival Probability",
     main = "Battery Survival: KM vs. Weibull Fit")

t_seq <- seq(0, max(surv_data$time_days), length.out = 200)
weibull_surv <- exp(- (t_seq / weibull_scale) ^ weibull_shape)  # S(t) Weibull

lines(t_seq, weibull_surv, col = "red", lwd = 2, lty = 2)
legend("bottomleft", legend = c("Kaplan–Meier (non-parametric)", "Weibull AFT model"), col = c("black", "red"), lty = c(1, 2), lwd = 2, bty = "n")

```


```{r}
# Analyze effect based on the usage intensity
# Define usage rate [hours/day] for each unit
surv_data$usage_rate <- surv_data$Total.usage.time / (surv_data$time_days)
surv_data$usage_rate[!is.finite(surv_data$usage_rate)] <- NA  # handle division by 0 if any time_days=0

# Define "High" vs "Low" usage group based on the median usage rate
median_rate <- median(surv_data$Total.usage.time / (surv_data$time_days), na.rm = TRUE)
data_filtered$UsageGroup <- ifelse((surv_data$usage_rate) >= median_rate, "High usage", "Low usage")

# KM curves by usage group
KM_by_usage <- survfit(Surv(time_days, Event) ~ UsageGroup, data = data_filtered)
# Plot survival curves for heavy vs light usage
plot(KM_by_usage, col = c("blue", "red"), xlab = "Time since Registration (days)", 
     ylab = "Survival Probability", 
     main = "Battery Survival by Usage Intensity")
legend("bottomleft", legend = c("High usage", "Low usage"), col = c("blue", "red"), lwd = 3)
```



```{r}
# Log-rank test for difference in survival between usage groups
survdiff(Surv(time_days, Event) ~ UsageGroup, data = data_filtered)
# We obtain a large Chi-square and a tiny p-value, so they indicate a significant difference between the two groups
```



```{r Bootstrap CI}
# Bootstrap confidence interval for L10 (10% failure time)
set.seed(123)
B <- 500   # number of bootstrap replicates
L10_boot <- numeric(B)
for(b in 1:B) {
  # sample subjects with replacement
  boot_indices <- sample(seq_len(nrow(surv_data)), size = nrow(surv_data), replace = TRUE)
  boot_sample <- surv_data[boot_indices, ]
  # fit Weibull AFT model on bootstrap sample
  boot_fit <- survreg(Surv(time_days, Event) ~ 1, data = boot_sample, dist = "weibull")
  boot_shape <- 1 / boot_fit$scale
  boot_scale <- exp(coef(boot_fit))
  L10_boot[b] <- boot_scale * (-log(0.9))^(1 / boot_shape)
}
# Calculate 95% CI from bootstrap distribution
L10_ci <- quantile(L10_boot, probs = c(0.025, 0.975))
L10_ci

# Two-sided 95% CI (descriptive)
L10_ci_95 <- quantile(L10_boot, c(0.025, 0.975))
L10_ci_95

# One-sided lower 95% bound (for “at least” claims)
L10_lower_95 <- quantile(L10_boot, 0.05)
L10_lower_95

# One-sided lower 90% bound
L10_lower_90 <- quantile(L10_boot, 0.10)
L10_lower_90

```




